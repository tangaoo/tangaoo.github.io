---
layout: post
title:  "protobuf"
categories: tool
tags:  protobuf
author: tangoo
mathjax: true
---


* content
{:toc}

项目中有很多自定义结构体类型的数据需要保存，然后上位机在读取解析用。写了一堆自定义协议的序列化与反序列化代码，又臭又长，而且序列化的协议是 word 文档，也就是协议跟代码是分家的，既然都分家了，那么不一致就不稀奇了。

[protobuf-c](https://github.com/protobuf-c/protobuf-c) 可以完美解决这个问题，当然 protobuf-c 还能解决客户端/服务器通信的问题。






{% raw %}


## 1. 安装

* 安装 protobuf

```console
git clone https://github.com/protocolbuffers/protobuf.git
cd protobuf
git submodule update --init --recursive
./autogen.sh
./configure
make
make check  # make check 失败的话没关系，继续下面的安装
sudo make install
sudo ldconfig
```

安装不成功的话，检查依赖`sudo apt-get install autoconf automake libtool curl make g++ unzip`

* 安装 protobuf-c

```console
git clone https://github.com/protobuf-c/protobuf-c.git
./autogen.sh && ./configure && make && make install
```

## 2. protobuf-c 生成协议代码

* 编辑 student.proto 文件

```cpp
syntax = "proto3";
  
message Student {
    required int32 id = 1;
    required string name = 2;
    required int32 socre = 3;
}
```

* 生成源文件

```console
protoc --c_out=. student.proto
```

生成.c和.h文件 student.pb-c.c student.pb-c.h

## 3. 编写代码

* 编写 student.c 文件
  
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "student.pb-c.h"

#define NAME_LEN 32

int main() {
    Student stu = STUDENT__INIT; // 初始化
    void *buf = NULL;
    unsigned int len;
    Student *msg = NULL;

    stu.name = (char*)malloc(NAME_LEN);
    stu.name = "test";

    len = student__get_packed_size(&stu);  // 算出大小
    printf("size of Student info : %u\n", len);
    buf = malloc(len);
    student__pack(&stu, buf); // 打包

    msg = student__unpack(NULL, len, buf); // 解包
    printf("msg name : %s\n", msg->name);

    student__free_unpacked(msg, NULL); // 释放空间

    free(buf);
    return 0;
}
```

* 编译 student.c 
  
```console
gcc student.c student.pb-c.c -o student -lprotobuf-c
```

注意要链接 protobuf-c 库。



{% endraw %}